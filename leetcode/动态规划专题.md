# 动态规划

为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的「状态」，图中的边则对应状态之间的「转移」，转移的选取就是动态规划中的「决策」。

#### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

```c++
// 1. 以j结尾数组，最大的和为dp[j]
dp[j] = max(a[j], dp[j-1] + a[j])
// 2. 分治
// 3. 直接遍历，对于比较a[j]和dp[j-1] + a[j]，实际上是比较dp[j-1]是否小于零，只需要维护一个sum遍历，遍历的过程中，if sum > 0 sum+=a[j] else sum = a[j].
```

#### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

