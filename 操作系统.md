主要阅读《操作系统导论》、《现代操作系统：原理与实现》

## 第五章 内存管理

### TLB的刷新

系统调用的时候通常不需要切换页表，AArch64是用了2个页表基址寄存器，x86则是内核和应用共用一个CR3寄存器。但是应用程序之间是不同的虚拟地址，需要切换页表所以需要刷新TLB。

现代AArch64的TLB有ASID、x86则有PCID，会在TLB上加上应用程序的ID来避免TLB的刷新

### 缺页异常

当操作系统访问到的虚拟页没有映射物理页的时候，会触发缺页异常，同时缺页异常函数(page fault handler)会进行处理。

x86上是14号异常。缺页地址会放在CR2寄存器上。

操作系统还有会预取指令来优化页的访问。

操作系统如何区分已分配未映射和未分配？Linux中应用程序虚拟地址被实现成多个**虚拟地址内存(VMA)**，page fault handler会判断页地址是否属于VMA，属于则是已分配但未映射。

### 虚拟内存功能

共享内存功能：写时拷贝、内存去重

**写时拷贝**：操作系统会在页表项的剩余位中标记是否可写。写时拷贝是让2个应用程序以只读的方式共享物理内存。写入会引发缺页异常（原因是违反权限）。page fault handler会重新分配一个拷贝过的物理页，权限为可读可写。

**内存去重**：操作系统定期扫描是否有相同的物理页

## 进程与线程

fork与vfork的区别：

vfork不会为子进程单独创建地址空间，而是共用父进程的地址空间。由于exec本来就会创建地址空间。所以使用vfork+exec比fork+exec节省了一次地址空间的拷贝。

### 多线程的地址空间

多线程的地址空间中，每个用户线程和内核线程都有自己的栈，切换的时候会切换对应的栈指针。堆是所有栈共用的，所以malloc需要同步源语。

### 上下文的切换

由于是一对一模型，所以用户线程之间的切换是首先用户线程切换到内核线程，再内核线程之间切换完成后切换回新的用户线程中。

时钟中断会触发线程的上下文切换，首先在内核态使用内核栈把用户态的上下文被保存下来。然后进行内核线程之间的切换，主要是切换页表还有切换内核栈。由于所有地址空间的内核部分相同，AArch只需要更新应用空间的页表基址寄存器。切换新的内核栈后，将上下文依次pop出来就可以恢复到寄存器中了。然后返回到用户态即可。

纤程(fiber)：操作系统支持的用户态线程。协程(coroutine)：编程语言支持的用户态线程。

## 第六章 操作系统调度

TODO
